import re
from asteval import Interpreter
from collections import Counter

class CountdownReward:
    """
    A multi-component reward function for the Countdown math problem.
    It evaluates formatting, constraint adherence, and mathematical correctness.
    """
    def __init__(self, proximity_bonus=2.0, proximity_threshold=5):
        self.aeval = Interpreter()
        self.proximity_bonus = proximity_bonus
        self.proximity_threshold = proximity_threshold

    def _parse_completion(self, completion):
        """Parses the completion for <think> and <answer> tags."""
        think_match = re.search(r"<think>(.*?)</think>", completion, re.DOTALL)
        answer_match = re.search(r"<answer>(.*?)</answer>", completion, re.DOTALL)
        
        if think_match and answer_match:
            return answer_match.group(1).strip()
        return None

    def _check_number_usage(self, expression, available_numbers):
        """
        Checks if the expression uses the available numbers correctly.
        Each number must be used exactly once.
        """
        used_numbers_str = re.findall(r'\d+', expression)
        try:
            used_numbers = [int(n) for n in used_numbers_str]
        except ValueError:
            return False, "invalid_number_format"

        return Counter(used_numbers) == Counter(available_numbers), "number_mismatch"

    def calculate_reward(self, completion, numbers, target):
        """
        Calculates the total reward for a single completion.
        
        Args:
            completion (str): The string generated by the LLM.
            numbers (list[int]): The list of numbers available for the problem.
            target (int): The target number to reach.

        Returns:
            float: The calculated reward score.
        """
        reward = 0.0
        
        # 1. Formatting check
        expression = self._parse_completion(completion)
        if expression is None:
            return -5.0  # Heavy penalty for incorrect format

        reward += 2.0  # Reward for correct format

        # 2. Number usage check
        usage_correct, reason = self._check_number_usage(expression, numbers)
        if not usage_correct:
            return -4.0 # Heavy penalty for using wrong numbers

        reward += 3.0 # Reward for correct number usage

        # 3. Safe evaluation and correctness check
        try:
            # Safely evaluate the expression
            result = self.aeval.eval(expression)
            
            if result == target:
                reward += 10.0  # Large reward for exact correctness
            elif abs(result - target) <= self.proximity_threshold:
                # Proximity bonus for being close
                reward += self.proximity_bonus
            else:
                # Penalty for being far from the target
                reward -= 2.0

        except Exception:
            # Penalty for any evaluation error (e.g., syntax error, division by zero)
            return -3.0

        return reward